#!groovy

def helmRbacConfig = '''
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: tiller
    namespace: kube-system
'''

def ingValue = '''
rbac:
 create: true
controller:
 service:
   annotations:
     service.beta.kubernetes.io/aws-load-balancer-type: nlb
     service.beta.kubernetes.io/aws-load-balancer-internal: true
   enableHttp: true
   enableHttps: false
'''


pipeline {
    parameters {
        string(name: 'PRODUCT_DOMAIN_NAME', defaultValue: '')
        string(name: 'ENVIRONMENT_TYPE', defaultValue: '')
        string(name: 'AWS_ACCOUNT_NUMBER', defaultValue: '')
        string(name: 'AWS_REGION', defaultValue: '')
    }
    agent { label 'jenkins-terraform' }
    stages {
        stage('install required software') {
            steps {
                container('terraform') {
                    withCustomEnv() {
                        sh '''#!/bin/bash -x
                        whoami
                        pwd
                        wget -O kops https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)/kops-linux-amd64
                        chmod +x ./kops
                        mv ./kops /usr/local/bin/
                        yum --disableplugin=fastestmirror install -y openssl
                        
                        curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get > get_helm.sh
                        chmod 700 get_helm.sh                                                   
                        ./get_helm.sh 
                        
                        ls -al /usr/local/bin
                        kubectl --client=true version
                        kops version
                        helm version --client
                        '''
                    }
                }
            }
        }
        stage('retrieve kubectl config') {
            steps {
                container('terraform') {
                    withCustomEnv() {
                        withAWS(role:'KopsCrossAccount', roleAccount:params.AWS_ACCOUNT_NUMBER) {
                            sh '''#!/bin/bash -x
                            kops --state s3://kops-${AWS_ACCOUNT_NUMBER}-${AWS_REGION}-${PRODUCT_DOMAIN_NAME}-${ENVIRONMENT_TYPE} export kubecfg ${PRODUCT_DOMAIN_NAME}-${ENVIRONMENT_TYPE}.k8s.local
                            pwd
                            ls -al ~/.kube
                            '''
                        }
                    }
                }
            }
        }
        stage('Init helm') {
            steps {
                dir("operations/$AWS_REGION/env") {
                    container('terraform') {
                        withCustomEnv() {
                            writeFile file: 'helm-rbac-config.yaml', text: helmRbacConfig
                            sh 'kubectl create -f helm-rbac-config.yaml || true'
                            sh 'helm init --service-account tiller --wait --upgrade'
                        }
                    }
                }
            }
        }
    }
}
void withCustomEnv(List envVars = [],  def body) {
    List proxies =[]
    List envVariables = [
        'GIT_SSH_COMMAND=ssh -o StrictHostKeyChecking=no',
        "AWS_REGION=${params.AWS_REGION}", "AWS_ACCOUNT_NUMBER=${params.AWS_ACCOUNT_NUMBER}", 
        "PRODUCT_DOMAIN_NAME=${params.PRODUCT_DOMAIN_NAME}", "ENVIRONMENT_TYPE=${params.ENVIRONMENT_TYPE}",
        "CONFIG_REPO_URL=${params.CONFIG_REPO_URL}", "CONFIG_REPO_DIR=${params.CONFIG_REPO_DIR}"
    ]
    withAWSParameterStore(credentialsId: '', namePrefixes: '', naming: 'absolute', path: '/proxy', recursive: true, regionName: "${params.AWS_REGION}") {
        script {
            if (env.PROXY_HTTP) {
                proxies << "http_proxy=$PROXY_HTTP"
            }
            if (env.PROXY_HTTPs) {
                proxies << "https_proxy=$PROXY_HTTPS"
            }
            if (env.PROXY_NO) {
                proxies << "no_proxy=$PROXY_NO"
            }
            envVariables.addAll(proxies)
        }
    }
    envVariables.addAll(envVars)
    withEnv(envVariables) {
        body.call()
    }
}
